Program 18 : Construct a tree using arrays
#include <stdio.h> 
#include <stdlib.h> 
struct Node { 
int data; 
struct Node *next; 
}; 
struct Node *head = NULL; 
struct Node *createNode(int data) { 
struct Node *newNode = (struct Node *)malloc(sizeof(struct Node)); 
newNode->data = data; 
newNode->next = NULL; 
return newNode; 
} 
void insertAtBeginning(int data) { 
struct Node *newNode = createNode(data); 
newNode->next = head; 
head = newNode; 
} 

void insertAtEnd(int data) { 
struct Node *newNode = createNode(data); 
if (head == NULL) { 
head = newNode; 
return; 
} 
struct Node *temp = head; 
while (temp->next != NULL) 
temp = temp->next; 
temp->next = newNode; 
} 
void insertAtPosition(int data, int pos) { 
if (pos == 1 || head == NULL) { 
insertAtBeginning(data); 
return; 
} 
struct Node *newNode = createNode(data); 
struct Node *temp = head; 
int i; 
for (i = 1; i < pos - 1 && temp->next != NULL; i++) 
temp = temp->next; 
newNode->next = temp->next; 
temp->next = newNode; 
} 
void display() { 
struct Node *temp = head; 
if (temp == NULL) { 
printf("List is empty\n"); 
return; 
} 
printf("List: "); 
while (temp != NULL) { 
printf("%d -> ", temp->data); 
temp = temp->next; 
} 
printf("NULL\n"); 
} 

int main() { 
int choice, data, pos; 
while (1) { 
printf("\n1. Insert at beginning"); 
printf("\n2. Insert at end"); 
printf("\n3. Insert at position"); 
printf("\n4. Display"); 
printf("\n5. Exit"); 
printf("\nEnter your choice: "); 
scanf("%d", &choice); 
switch (choice) { 
case 1: 
printf("Enter data: "); 
scanf("%d", &data); 
insertAtBeginning(data); 
break; 
case 2: 
printf("Enter data: "); 
scanf("%d", &data); 
insertAtEnd(data); 
break; 
case 3: 
printf("Enter data: "); 
scanf("%d", &data); 
printf("Enter position: "); 
scanf("%d", &pos); 
insertAtPosition(data, pos); 
break; 
case 4: 
display(); 
break; 
case 5: 
system("getmac"); 
return 0; 
default: 
printf("Invalid choice\n"); 
} 
} 
} 

Program 19 : Construct a binary tree using queues
#include <stdio.h>
#include <stdlib.h>
struct node {
int data;
struct node *left, *right;
};
struct node *newNode(int x) {
struct node *t = (struct node *)malloc(sizeof(struct node));
t->data = x;
t->left = t->right = NULL;
return t;
}
struct node *insert(struct node *root, int x) {
if (root == NULL) return newNode(x);
if (x < root->data)
root->left = insert(root->left, x);
else if (x > root->data)
root->right = insert(root->right, x);
return root;
}
struct node *minValueNode(struct node *root) {
struct node *cur = root;
while (cur && cur->left != NULL)
cur = cur->left;
return cur;
}
struct node *deleteNode(struct node *root, int key) {
if (root == NULL) return root;
if (key < root->data)
root->left = deleteNode(root->left, key);
else if (key > root->data)
root->right = deleteNode(root->right, key);
else {
if (root->left == NULL) {
struct node *temp = root->right;
free(root);
return temp;
} else if (root->right == NULL) {
struct node *temp = root->left;
free(root);
return temp;
}
struct node *succ = minValueNode(root->right);
root->data = succ->data;
root->right = deleteNode(root->right, succ->data);
}
return root;
}
void inorder(struct node *root) {
if (root == NULL) return;
inorder(root->left);
printf("%d ", root->data);

inorder(root->right);
}
int main() {
struct node *root = NULL;
int n, x, key, i;
printf("Enter number of nodes: ");
scanf("%d", &n);
printf("Enter %d values:\n", n);
for (i = 0; i < n; i++) {
scanf("%d", &x);
root = insert(root, x);
}
printf("Inorder before deletion: ");
inorder(root);
printf("\n");
printf("Enter key to delete: ");
scanf("%d", &key);
root = deleteNode(root, key);
printf("Inorder after deletion: ");
inorder(root);
printf("\n");
system("getmac"); 
return 0;
}
 


Program 20 : Insertion of nodes

#include <stdio.h> 
#include <stdlib.h> 
struct Node { 
int data; 
struct Node *left, *right; 
}; 
struct Node *newNode(int x) { 
struct Node *t = (struct Node *)malloc(sizeof(struct Node)); 
t->data = x; 
t->left = t->right = NULL; 
return t; 
} 
void levelOrder(struct Node *root) { 
if (root == NULL) return; 
struct Node *queue[100]; 
int front = 0, rear = 0; 
queue[rear++] = root; 
while (front != rear) { 
struct Node *temp = queue[front++]; 
printf("%d ", temp->data); 
if (temp->left != NULL) queue[rear++] = temp->left; 
if (temp->right != NULL) queue[rear++] = temp->right; 
} 
printf("\n"); 
} 
int main() { 
struct Node *root = newNode(1); 
root->left = newNode(2); 
root->right = newNode(3); 
root->left->left = newNode(4); 
root->left->right = newNode(5); 
levelOrder(root); 
system("getmac"); 
return 0;
 

Program 21 : Deletion of nodes
#include <stdio.h> 
#include <stdlib.h> 
#define MAXV 20 
struct Node { 
int v; 
struct Node *next; 
}; 
struct Graph { 
int V; 
struct Node *adj[MAXV]; 
}; 
struct Graph *createGraph(int V) { 
struct Graph *g = malloc(sizeof(struct Graph)); 
g->V = V; 
for (int i = 0; i < V; i++) 
g->adj[i] = NULL; 
return g; 
} 
void addEdge(struct Graph *g, int src, int dest) { 
struct Node *n = malloc(sizeof(struct Node)); 
n->v = dest; 
n->next = g->adj[src]; 
g->adj[src] = n; 
n = malloc(sizeof(struct Node)); 
n->v = src; 
n->next = g->adj[dest]; 
g->adj[dest] = n; 
} 
void BFS(struct Graph *g, int start) { 
int visited[MAXV] = {0}; 
int queue[MAXV], front = 0, rear = 0; 
visited[start] = 1; 
queue[rear++] = start; 
printf("BFS: "); 
while (front != rear) { 
int u = queue[front++]; // dequeue 
printf("%d ", u); 
for (struct Node *p = g->adj[u]; p != NULL; p = p->next) { 
int v = p->v; 
if (!visited[v]) { 
visited[v] = 1; 
queue[rear++] = v; // enqueue 
} 
} 
} 
printf("\n"); 
} 
void DFS(struct Graph *g, int start) { 
int visited[MAXV] = {0}; 
int stack[MAXV], top = -1; 
stack[++top] = start; 
printf("DFS: "); 
while (top != -1) { 
int u = stack[top--]; 
if (visited[u]) continue; 
visited[u] = 1; 
printf("%d ", u); 
for (struct Node *p = g->adj[u]; p != NULL; p = p->next) { 
int v = p->v; 
if (!visited[v]) 
stack[++top] = v; 
} 
} 
printf("\n"); 
} 
int main() {
 
int V = 5; 
struct Graph *g = createGraph(V); 
addEdge(g, 0, 1); 
addEdge(g, 0, 2); 
addEdge(g, 1, 3); 
addEdge(g, 1, 4); 
addEdge(g, 2, 3); 
BFS(g, 0); 
DFS(g, 0); 
system("getmac"); 
return 0;
}
 

Program22 : Depth search tree
#include <stdio.h> 
#include <stdlib.h> 
int main() { 
int i; 
int *a = (int *)malloc(5 * sizeof(int));  
int *b = (int *)calloc(5, sizeof(int)); 
if (a == NULL || b == NULL) { 
printf("Memory allocation failed\n"); 
return 0; 
} 
printf("Values in array from malloc:\n"); 
for (i = 0; i < 5; i++) 
printf("%d ", a[i]); 
printf("\n"); 
printf("Values in array from calloc:\n"); 
for (i = 0; i < 5; i++) 

printf("%d ", b[i]); // all 0 
printf("\n"); 
free(a); 
free(b); 
system("getmac"); 
return 0;
 

program 23 : Breadth search tree
#include <stdio.h> 
#include <stdlib.h> 
struct node { 
int data; 
struct node *next; 
}; 
struct node *last = NULL; 
void insert_end(int x) { 
struct node *temp = (struct node *)malloc(sizeof(struct node)); 
temp->data = x; 
if (last == NULL) { 
last = temp; 
last->next = last; 
} else { 
temp->next = last->next; 
last->next = temp; 
last = temp; 
} } 
void delete_value(int x) {
 
if (last == NULL) return; 
struct node *curr = last->next, *prev = last; 
do { 
if (curr->data == x) break; 
prev = curr; 
curr = curr->next; 
} while (curr != last->next); 
if (curr->data != x) return; 
if (curr == last && curr->next == last) last = NULL; 
else { 
prev->next = curr->next; 
if (curr == last) last = prev; 
} 
free(curr); 
} 
void display() { 
if (last == NULL) { 
printf("List is empty\n"); 
return; 
} 
struct node *p = last->next; 
printf("List: "); 
do { 
printf("%d ", p->data); 
p = p->next; 
} while (p != last->next); 
printf("\n"); 
} 
int main() { 
insert_end(10); 
insert_end(20); 
insert_end(30); 
display(); 
delete_value(20); 
display(); 
system("getmac"); 
return 0; 
}
 

Program 24 : Level order
#include <stdio.h> 
#include <string.h> 
#include<stdlib.h> 
int main() { 
char s1[100], s2[100]; 
int res; 
printf("Enter first string: "); 
scanf("%99s", s1); 
printf("Enter second string: "); 
scanf("%99s", s2); 
res = strcmp(s1, s2); 
if (res == 0) 
printf("Strings are equal.\n"); 
else if (res > 0) 
printf("First string is greater.\n"); 
else 
printf("First string is smaller.\n"); 
system("getmac"); 
return 0; 
} 

Program 25 : DFS and BFS using adjacency list (use stacks and queues in program)
#include <stdio.h> 
#include <stdlib.h> 
struct node { 
int data; 
struct node *next; 
}; 
struct node *head = NULL; 
void display() { 
struct node *temp = head; 
if (temp == NULL) { 
printf("List is empty\n"); 
return; 
} 
printf("List: "); 
while (temp != NULL) { 
printf("%d -> ", temp->data); 
temp = temp->next; 
} 
printf("NULL\n"); 
} 
void insert_at_pos(int data, int pos) { 
struct node *newNode = (struct node *)malloc(sizeof(struct node)); 
newNode->data = data; 
newNode->next = NULL; 
if (pos == 1 || head == NULL) { 
newNode->next = head;
 
head = newNode; 
return; 
} 
struct node *temp = head; 
int i; 
for (i = 1; i < pos - 1 && temp->next != NULL; i++) 
temp = temp->next; 
newNode->next = temp->next; 
temp->next = newNode; 
} 
void delete_at_pos(int pos) { 
if (head == NULL) { 
printf("List is empty\n"); 
return; 
} 
struct node *temp = head; 
if (pos == 1) { 
head = temp->next; 
free(temp); 
return; 
} 
int i; 
for (i = 1; i < pos - 1 && temp->next != NULL; i++) 
temp = temp->next; 
if (temp->next == NULL) { 
printf("Position out of range\n"); 
return; 
} 
struct node *del = temp->next; 
temp->next = del->next; 
free(del); 
} 
int main() { 
int choice, data, pos; 
while (1) { 
printf("\n1. Insert at position"); 
printf("\n2. Delete at position");
 
printf("\n3. Display"); 
printf("\n4. Exit"); 
printf("\nEnter your choice: "); 
scanf("%d", &choice); 
switch (choice) { 
case 1: 
printf("Enter data: "); 
scanf("%d", &data); 
printf("Enter position: "); 
scanf("%d", &pos); 
insert_at_pos(data, pos); 
break; 
case 2: 
printf("Enter position to delete: "); 
scanf("%d", &pos); 
delete_at_pos(pos); 
break; 
case 3: 
display(); 
break; 
case 4: 
exit(0); 
default: 
printf("Invalid choice\n"); 
} 
} 
system("getmac"); 
return 0; 
}
 

Program 26 : Calloc and Malloc functions checking if junk/zero is initialized to them
#include <stdio.h> 
#include <stdlib.h> 
struct Node { 
int data; 
struct Node *left, *right; 
}; 
struct Node *newNode(int data) { 
struct Node *temp = (struct Node *)malloc(sizeof(struct Node)); 
temp->data = data; 
temp->left = temp->right = NULL; 
return temp; 
} 
void preorder(struct Node *root) { 
if (root == NULL) return; 
printf("%d ", root->data); 
preorder(root->left); 

preorder(root->right); 
} 
void inorder(struct Node *root) { 
if (root == NULL) return; 
inorder(root->left); 
printf("%d ", root->data); 
inorder(root->right); 
} 
void postorder(struct Node *root) { 
if (root == NULL) return; 
postorder(root->left); 
postorder(root->right); 
printf("%d ", root->data); 
} 
int main() { 
struct Node *root = newNode(1); 
root->left = newNode(2); 
root->right = newNode(3); 
root->left->left = newNode(4); 
root->left->right = newNode(5); 
printf("Preorder : "); 
preorder(root); 
printf("\n"); 
printf("Inorder : "); 
inorder(root); 
printf("\n"); 
printf("Postorder: "); 
postorder(root); 
printf("\n"); 
system("getmac"); 
return 0; 
}
 

Program 27 : Circular linked lists basic operations
#include <stdio.h> 
#include <stdlib.h> 
struct node 
{ 
int data; 
struct node *next; 
}; 
int main() 
{ 
struct node *head = NULL, *temp, *newnode; 
int n, i; 
printf("Enter number of nodes: "); 
scanf("%d", &n); 
for (i = 0; i < n; i++) 
{ 
newnode = malloc(sizeof(struct node)); 
printf("Enter value: "); 
scanf("%d", &newnode->data); 
newnode->next = NULL; 
if (head == NULL) 
{ 
head = newnode; 
temp = newnode; 
} 
else 
{ 
temp->next = newnode; 

temp = newnode; 
} 
} 
temp = head; 
while (temp != NULL) 
{ 
printf("%d ", temp->data); 
temp = temp->next; 
} 
system("getmac"); 
return 0; 
}
 

Program 28 : How to implement comparison of 2 strings using built in function
#include <stdio.h> 
#include <stdlib.h> 
int main() { 
int n, i; 
int *a; 
printf("Enter number of elements: "); 
scanf("%d", &n); 
a = (int *)calloc(n, sizeof(int)); 
if (a == NULL) { 
printf("Memory not allocated.\n"); 
return 0; 
} 		

printf("Array elements after initialization:\n"); 
for (i = 0; i < n; i++) { 
printf("%d ", a[i]); 
} 
free(a); 
system("getmac"); 
return 0; 
}
 

Program 29 : In linked list insertion in the middle and deletion in the middle
#include <stdio.h> 
#include<stdlib.h> 
struct node 
{ 
int data; 
struct node *next; 
}; 
int main() 
{ 
struct node a, b; 
printf("Enter value for first node: "); 
scanf("%d", &a.data); 
printf("Enter value for second node: "); 
scanf("%d", &b.data); 
a.next = &b; 
b.next = NULL; 
printf("%d\n", a.data); 
printf("%d\n", a.next->data); 
system("getmac"); 
return 0; 
} 

Program 30  : Binary tree traversal
 #include <stdio.h> 
#include <time.h> 
#include<stdlib.h> 
int main() 
{ 
int a[50], n, i, pos; 
clock_t t1, t2; 
printf("Enter size: "); 
scanf("%d", &n); 
printf("Enter elements:\n"); 
for (i = 0; i < n; i++) 
scanf("%d", &a[i]); 
printf("Enter position to insert: "); 
scanf("%d", &pos); 
t1 = clock(); 
for (i = n; i >= pos; i--) 
a[i] = a[i - 1]; 
n++; 
t2 = clock(); 
printf("Insertion time: %f\n", (double)(t2 - t1) / CLOCKS_PER_SEC); 
printf("Enter position to delete: "); 
scanf("%d", &pos); 
t1 = clock(); 
for (i = pos - 1; i < n - 1; i++) 
a[i] = a[i + 1]; 
n--; 
t2 = clock(); 
printf("Deletion time: %f\n", (double)(t2 - t1) / CLOCKS_PER_SEC); 
system("getmac"); 
return 0; 
}
 

Program 31 : Circular Queue using Array (Modulo division , Queue full , Queue empty)
#include <stdio.h>
#include<stdlib.h>
#define MAX 5
int q[MAX];
int front = -1, rear = -1;
int isEmpty() {
    return front == -1;
}
int isFull() {
    return (rear + 1) % MAX == front;
}
void enqueue(int x) {
    if (isFull()) {
        printf("Queue is Full\n");
        return;
    }
    if (isEmpty()) {
        front = rear = 0;
    } else {
        rear = (rear + 1) % MAX;
    }
    q[rear] = x;
}
int dequeue() {
    int x;
    if (isEmpty()) {
        printf("Queue is Empty\n");
        return -1;
    }
    x = q[front];
    if (front == rear) {      
        front = rear = -1;
    } else {
        front = (front + 1) % MAX;
    }
    return x;
}
void display() {
    if (isEmpty()) {
        printf("Queue is Empty\n");
        return;
    }
    printf("Queue elements: ");
    int i = front;
    while (1) {
        printf("%d ", q[i]);
        if (i == rear) break;
        i = (i + 1) % MAX;
    }
System(“getmac”);
    printf("\n");
}
 
 

Program32 : Sparse Matrix representation using Linked list
#include <stdio.h>
#include<stdlib.h>
int main() {
    int row_pos[] = {0, 0, 1, 1, 3, 3, 3};
    int col_pos[] = {2, 4, 2, 3, 1, 2, 4};
    int val[]     = {3, 4, 5, 7, 2, 6, 4};
    int i, n = 7;
    printf("%-16s", "Row_position:");
    for (i = 0; i < n; i++)
        printf("%d ", row_pos[i]);
    printf("\n");
    printf("%-16s", "Column_position:");
    for (i = 0; i < n; i++)
        printf("%d ", col_pos[i]);
    printf("\n");
    printf("%-16s", "Value:");
    for (i = 0; i < n; i++)
        printf("%d ", val[i]);
    printf("\n");
    system(“getmac”);
    return 0;
}
